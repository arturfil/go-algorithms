package helpers

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"time"
)

type Problem struct {
    Done bool `json:"done"`
    Title string `json:"title"`
    IsFrom75 bool `json:"isFrom75"`
    Category string `json:"category"`
}

// RandomProblem - gets the data from GetProblemsFromJsonData & from there,
// it choosees a random problem to solve in leetcode
func ChooseRandomProblem() {

    // list flag ptr 
    listPtr := flag.String("list", "all", "flag to filter problems by")
    
    // category flag ptr
    ctgyPtr := flag.String("category", "all", "flag to filter by category")

    // parse values from flags
    flag.Parse()

    isFrom75 := false
    if *listPtr == "isFrom75" {
        isFrom75 = true
    } else {
        isFrom75 = false
    }

    var notDone []Problem
    problems := GetProblemsFromJsonData()
        
    for i := 0; i < len(problems); i++ {

        if (*ctgyPtr != "all" || *listPtr != "all") {

            if problems[i].Category == *ctgyPtr {
                notDone = append(notDone, problems[i])
            }
            
            if problems[i].isFrom75 == isFrom75 {


        } else {

            if problems[i].Done == false {
                notDone = append(notDone, problems[i])
            }
        }
               
    }

    fmt.Println("list", *listPtr)
    fmt.Println("ctgyPtr", *ctgyPtr)

    rand.Seed(time.Now().UnixNano()) 
    randIdx := rand.Intn(len(notDone) - 0 + 1) + 0
    
    fmt.Println("Problem chosen --->", notDone[randIdx].Title)
}

// GetProblemsFromJsonData - gets the data from a json file and returns it into a slice
func GetProblemsFromJsonData() []Problem {
    
    problems := struct {Problems []Problem}{}

    file, err := os.Open("data.json")
    if err != nil { fmt.Println(err) }

    byteVal, _ := ioutil.ReadAll(file)
    json.Unmarshal(byteVal, &problems)

    return problems.Problems
}

// PrintDoneProblems - displyas problems done
func PrintDoneProblems() {
    problems := GetProblemsFromJsonData() 
    doneProblems := []Problem{}

    for _, p := range problems {
        if p.Done == true {
            doneProblems = append(doneProblems, p)
            fmt.Println(p)
        }
    }

    fmt.Println("Done problems", len(doneProblems))
}
